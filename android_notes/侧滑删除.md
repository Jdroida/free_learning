#### 首先实现最核心的view group

```
package com.example.learn;

import android.content.Context;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.FrameLayout;

import androidx.core.view.ViewCompat;
import androidx.customview.widget.ViewDragHelper;
public class DragViewGroup extends FrameLayout {

    private final String TAG = "DragViewGroup";

    private ViewDragHelper mViewDragHelper;
    private View mMenuView, mMainView;
    private int mMenuWidth;
    private boolean isMenuOpen = false;
    
    public DragViewGroup(Context context) {
        super(context);
        initView();
    }

    public DragViewGroup(Context context, AttributeSet attrs) {
        super(context, attrs);
        initView();
    }

    public DragViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initView();
    }

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        // 确保有足够的子View
        if (getChildCount() >= 2) {
            mMenuView = getChildAt(0);
            mMainView = getChildAt(1);
        }
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        // 设置菜单宽度为总宽度的1/3
        mMenuWidth = getMeasuredWidth() / 3;
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        super.onLayout(changed, left, top, right, bottom);

        if (mMenuView != null && mMainView != null) {
            // 布局菜单视图（隐藏在左侧or右侧）
            //mMenuView.layout(-mMenuWidth, 0, 0, bottom - top);
            mMenuView.layout(right, 0, right+mMenuWidth, bottom - top);

            // 布局主视图
            int mainLeft = isMenuOpen ? mMenuWidth : 0;
            mMainView.layout(mainLeft, 0, mainLeft + (right - left), bottom - top);
        }
    }

    @Override
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        if (mViewDragHelper != null) {
            return mViewDragHelper.shouldInterceptTouchEvent(ev);
        }
        return super.onInterceptTouchEvent(ev);
    }

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (mViewDragHelper != null) {
            mViewDragHelper.processTouchEvent(event);
            return true;
        }
        return super.onTouchEvent(event);
    }

    private void initView() {
        mViewDragHelper = ViewDragHelper.create(this, callback);
    }

    private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {

        @Override
        public boolean tryCaptureView(View child, int pointerId) {
            //指定可以滑动的view
            return child == mMainView;
        }

        @Override
        public void onViewCaptured(View capturedChild, int activePointerId) {
            super.onViewCaptured(capturedChild, activePointerId);
        }

        @Override
        public void onViewDragStateChanged(int state) {
            super.onViewDragStateChanged(state);
        }

        @Override
        public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
            super.onViewPositionChanged(changedView, left, top, dx, dy);
            // 同时移动菜单视图
            if (mMenuView != null) {
                //这里可以控制菜单的移动范围，需要与on layout的逻辑匹配。菜单在左侧时，向右滑动展示菜单。菜单在右侧时，向左滑动展示菜单
                //mMenuView.layout(left - mMenuWidth, 0, left, mMenuView.getBottom());
                mMenuView.layout(changedView.getWidth()+left, 0, left + mMenuWidth+changedView.getWidth(), mMenuView.getBottom());
            }
            invalidate();
        }

        @Override
        public int clampViewPositionVertical(View child, int top, int dy) {
            return 0;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            // 限制主视图的移动范围
            //return Math.max(0, Math.min(left, mMenuWidth));
            return left;
        }

        @Override
        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            super.onViewReleased(releasedChild, xvel, yvel);
            //手指离开屏幕后的操作
            /*int finalLeft;
            if (mMainView.getLeft() < mMenuWidth / 2) {
                // 关闭菜单
                finalLeft = 0;
                isMenuOpen = false;
            } else {
                // 打开菜单
                finalLeft = mMenuWidth;
                isMenuOpen = true;
            }

            if (mViewDragHelper.smoothSlideViewTo(mMainView, finalLeft, 0)) {
                ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
            }*/
        }

        @Override
        public int getViewHorizontalDragRange(View child) {
            return mMenuWidth;
        }
    };

    @Override
    public void computeScroll() {
        //处理平滑移动的动画细节
        if (mViewDragHelper != null && mViewDragHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }

    // 提供外部方法来控制菜单状态
    public void openMenu() {
        if (mViewDragHelper != null && mMainView != null) {
            if (mViewDragHelper.smoothSlideViewTo(mMainView, mMenuWidth, 0)) {
                isMenuOpen = true;
                ViewCompat.postInvalidateOnAnimation(this);
            }
        }
    }

    public void closeMenu() {
        if (mViewDragHelper != null && mMainView != null) {
            if (mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0)) {
                isMenuOpen = false;
                ViewCompat.postInvalidateOnAnimation(this);
            }
        }
    }

    public boolean isMenuOpen() {
        return isMenuOpen;
    }
}
```

#### 然后是简单的adapter

```
package com.example.learn

import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Button
import android.widget.TextView
import androidx.recyclerview.widget.RecyclerView
class MyAdapter(
    private val dataList: MutableList<String>
) : RecyclerView.Adapter<MyAdapter.ViewHolder>() {

    override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
        val view = LayoutInflater.from(parent.context).inflate(R.layout.item_layout, parent, false)
        return ViewHolder(view)
    }

    override fun onBindViewHolder(holder: ViewHolder, position: Int) {
        holder.bind(dataList[position], position)
    }

    override fun getItemCount(): Int = dataList.size

    fun removeItem(position: Int) {
        if (position >= 0 && position < dataList.size) {
            dataList.removeAt(position)
            notifyItemRemoved(position)
            // 更新后续项目的索引
            if (position < dataList.size) {
                notifyItemRangeChanged(position, dataList.size - position)
            }
        }
    }

    inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) {
        private val textView: TextView = itemView.findViewById(R.id.textView)
        private val deleteButton: Button = itemView.findViewById(R.id.deleteButton)
        private val dragViewGroup: DragViewGroup = itemView as DragViewGroup

        fun bind(item: String, position: Int) {
            textView.text = item

            // 设置删除按钮的点击事件
            deleteButton.setOnClickListener {
                // 可先关闭菜单，然后删除项目
                //dragViewGroup.closeMenu()
                // 延迟删除，让关闭动画先完成
                itemView.postDelayed({
                    removeItem(position)
                }, 200)
            }

            // 确保每个item开始时菜单都是关闭的
            //dragViewGroup.closeMenu()
        }
    }
}
```

#### 简单的xml item布局

```
<?xml version="1.0" encoding="utf-8"?>
<com.example.learn.DragViewGroup xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="wrap_content">

    <!-- 菜单视图（侧边栏） -->
    <LinearLayout
        android:layout_width="120dp"
        android:layout_height="match_parent"
        android:background="#ff4444"
        android:orientation="horizontal"
        android:gravity="center">

        <Button
            android:id="@+id/deleteButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="删除"
            android:background="#66ff0000"
            android:textColor="@color/white"/>

    </LinearLayout>

    <!-- 主视图 -->
    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:background="@color/white"
        android:padding="16dp"
        android:orientation="horizontal">

        <TextView
            android:id="@+id/textView"
            android:layout_width="0dp"
            android:layout_height="wrap_content"
            android:layout_weight="1"
            android:text="Item"
            android:textSize="16sp" />

    </LinearLayout>

</com.example.learn.DragViewGroup>
```

#### 最后使用这个recycler view即可

```
package com.example.learn

import android.os.Bundle
import androidx.appcompat.app.AppCompatActivity
import androidx.recyclerview.widget.DividerItemDecoration
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.RecyclerView

class MainActivity : AppCompatActivity() {
    private lateinit var recyclerView: RecyclerView
    private lateinit var adapter: MyAdapter
    private lateinit var itemsList: MutableList<String>

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        recyclerView = findViewById(R.id.recycler_view)

        // 准备数据
        itemsList = mutableListOf()
        for (i in 1..20) {
            itemsList.add( "这是第 $i 个项目")
        }

        // 设置适配器
        adapter = MyAdapter(itemsList)
        recyclerView.adapter = adapter
        recyclerView.layoutManager = LinearLayoutManager(this)

        // 可选：添加分割线
        recyclerView.addItemDecoration(DividerItemDecoration(this, DividerItemDecoration.VERTICAL))
    }
}
```

#### 参考主布局文件

```
<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
        android:id="@+id/recycler_view"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_marginTop="24dp"
        tools:listitem="@layout/item_layout" />

<!--    <com.example.learn.DragViewGroup-->
<!--        android:layout_width="match_parent"-->
<!--        android:layout_height="wrap_content"-->
<!--        android:layout_marginTop="200dp"-->
<!--        app:layout_constraintEnd_toEndOf="parent"-->
<!--        app:layout_constraintStart_toStartOf="parent"-->
<!--        app:layout_constraintTop_toTopOf="parent">-->

<!--        <TextView-->
<!--            android:id="@+id/textView"-->
<!--            android:layout_width="match_parent"-->
<!--            android:layout_height="wrap_content"-->
<!--            android:layout_gravity="start"-->
<!--            android:text="menu content" />-->

<!--        <TextView-->
<!--            android:layout_width="wrap_content"-->
<!--            android:layout_height="wrap_content"-->
<!--            android:layout_gravity="end"-->
<!--            android:text="main content" />-->
<!--    </com.example.learn.DragViewGroup>-->
</androidx.constraintlayout.widget.ConstraintLayout>
```
#### 关于一些技术总结
收藏点界面的侧滑菜单删除功能。从drawer layout里面扒拉出来的源码，结合view drag helper定制view group。 在on Measure
里可以设置子view宽度，比如菜单宽度为总宽度的三分之一。on layout可以控制子view的位置。比如菜单视图在左侧还是右侧。
onInterceptTouchEvent里面处理滑动冲突，判断逻辑交给view drag helper。shouldInterceptTouchEvent。在on touch中
使用view drag helper处理touch事件。processTouchEvent。实现view drag helper的callback。比如在tryCaptureView
里指定可以滑动的view。在onViewPositionChanged回调里根据主视图移动距离，展示菜单视图（如果不处理的话只滑动主视图，
菜单视图并不会跟着一起滑动出现）。还可以限制主视图水平方向移动范围clampViewPositionHorizontal。还可以定义手指离开屏幕后的逻辑，
比如滑动超过多少距离就完全打开菜单，否则就关闭菜单。computeScroll可以定义平滑移动的动画细节。