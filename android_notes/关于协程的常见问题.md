# Kotlin 协程与调度机制知识点复习

---

## 1. Kotlin 协程基础

### Kotlin 协程是什么？

- Kotlin 协程是轻量级的线程，提供更好的并发编程能力，能确保异步代码写法像同步一样简单。
- **挂起函数（`suspend`）：**
    - 一个协程可以在挂起点暂停，当前线程可以去做其他工作，等继续时恢复状态。
    - 挂起 ≠ 阻塞。

---

## 2. Kotlin 协程的启动方式

### 2.1 `launch` —— 启动协程，无返回值
- **特点**：类似 "fire-and-forget"，用于不需要结果的异步任务。
- **返回值**：`Job`，表示协程任务的生命周期。
- **应用场景**：
    - 数据库写入。
    - 日志上报。

```kotlin
launch(Dispatchers.IO) {
    // 异步任务
    database.insert(data)
}
```

### 2.2 `async` —— 启动协程，有返回值
- **特点**：返回值是 `Deferred<T>`，可以用 `await()` 获取结果。
- **返回值**：`Deferred<T>`。
- **应用场景**：
    - 并发执行多个任务、返回结果。
    - 适合计算任务。

```kotlin
val deferred = async { computeSomething() }
val result = deferred.await() // 获取值
```

### 2.3 `runBlocking` —— 阻塞式启动协程
- **特点**：用于测试或非协程环境下调用协程，阻塞当前线程。
- **返回值**：协程体最后的结果。
- **应用场景**：
    - 同步代码中调用协程。
    - **不推荐在生产环境使用**。

```kotlin
runBlocking {
    val userData = loadUserData()
    println(userData)
}
```

---

## 3. 协程上下文与调度器

协程调度器决定协程在哪个线程上运行，常用于**控制代码的执行环境**。

### 3.1 调度器分类与使用场景

| 调度器               | 描述                                                 | 适用场景                                     |
|----------------------|----------------------------------------------------|--------------------------------------------|
| `Dispatchers.Main`   | 主线程调度器，运行轻量任务                           | 更新 UI、轻量级计算、与用户交互                 |
| `Dispatchers.IO`     | IO 密集型任务专用，可动态扩展线程池                   | 网络请求、文件操作、数据库访问                  |
| `Dispatchers.Default`| CPU 密集型任务，线程数等于 CPU 核心数                | 图像/视频处理、加密解密、复杂算法                |
| `Dispatchers.Unconfined` | 动态调度器，随调用者环境执行，挂起后可能切线程       | 一般用于测试，不推荐生产中使用                  |
| 自定义调度器          | 手动定义独立线程池调度器                             | 固定的线程任务、隔离的并发任务                   |

### 3.2 调度器的使用

#### 网络请求 + 主线程更新 UI

```kotlin
suspend fun fetchData() {
    val data = withContext(Dispatchers.IO) {
        api.getData() // IO 线程
    }
    withContext(Dispatchers.Main) {
        textView.text = data // 主线程更新 UI
    }
}
```

#### CPU 密集型计算

```kotlin
suspend fun processData() {
    val result = withContext(Dispatchers.Default) {
        heavyComputationTask() // CPU 密集型任务
    }
    updateUI(result) // 回到主线程更新 UI
}
```

#### 动态线程池（自定义调度器）

```kotlin
val customDispatcher = newFixedThreadPoolContext(4, "CustomPool")

runBlocking(customDispatcher) {
    // 运行在自定义线程池中
    println("This runs on custom thread pool")
}
```

---

## 4. 线程切换: `withContext`

### **`withContext` 是什么？**

- **非独立协程构建器**：切换当前协程上下文（调度器），不会启动新协程。
- **常见用途**：
    - IO 线程与主线程切换。
    - CPU 密集型与网络请求交替。

### **用法**

#### 示例：IO 操作切换到 UI 线程

```kotlin
viewModelScope.launch {
    val data = withContext(Dispatchers.IO) {
        api.loadData() // IO 线程
    }
    withContext(Dispatchers.Main) {
        ui.update(data) // 主线程
    }
}
```

#### 示例：重计算与网络结合

```kotlin
val processedData = withContext(Dispatchers.Default) {
    computeRawData()
}
val finalResult = withContext(Dispatchers.IO) {
    api.postData(processedData)
}
```

---

## 5. 背压控制与依赖任务场景的实现

### **5.1 链式依赖任务 —— 顺序执行**

逻辑：上一个请求的结果作为输入传到下一个请求。

```kotlin
suspend fun fetchDataSequentially() {
    try {
        val result1 = api.request1()
        val result2 = api.request2(result1) // 依赖 result1
        val result3 = api.request3(result2) // 依赖 result2
        println("Final result: $result3")
    } catch (e: Exception) {
        println("Error: ${e.message}")
    }
}
```

---

### **5.2 并行 + 合并依赖**

逻辑：并行请求 A、B，合并结果为 C 的输入。

```kotlin
suspend fun fetchMergedResults() {
    val resultA = async { api.requestA() } // 并行 A
    val resultB = async { api.requestB() } // 并行 B

    val combinedResult = "${resultA.await()} + ${resultB.await()}"
    val resultC = api.requestC(combinedResult)
    println("Final result: $resultC")
}
```

**示例场景**：
1. **请求 A 获取用户信息，请求 B 获取好友列表**，然后合并为新请求:
   ```kotlin
   val userInfo = async { api.getUserInfo() }
   val friendsList = async { api.getFriendsList() }

   val dashboardData = getDashboardData(userInfo.await(), friendsList.await())
   ```

2. ~~动态拼接 API 查询关键字：A 表示搜索框输入，B 表示过滤条件，生成 C 的查询结果。~~

---

### **5.3 关于背压**
背压的本质实际上就是发送方速度超过了接收方的处理速度.常见的解决方案无外乎定制采样策略,防抖策略.但如果人力允许的话,我感觉
可以参考tcp调优策略.我发现背压问题在tcp中就是滑动窗口的容量大小调优问题.可以仿照ack+重传机制,设计一套动态调整缓冲池容量
的策略

## 6. 面试常见问题与答题参考

### 问题 1：启动协程有哪些方式？

| 启动器   | 返回类型       | 适用场景                       |
|---------|-------------|------------------------------|
| launch  | `Job`       | 无返回值的异步任务（如触发事件）       |
| async   | `Deferred`  | 需要返回值的任务（并发计算、网络请求）   |
| runBlocking | 函数返回值   | 主线程非协程时使用（需注意阻塞线程） |

---

### 问题 2：`withContext` 和 `async` 的区别？

| 分类           | `withContext`                  | `async`                          |
|----------------|-------------------------------|----------------------------------|
| 本质           | 切换线程执行代码，不启动新协程      | 启动新协程                       |
| 是否新协程      | ❌ 否                          | ✅ 是                           |
| 是否并发       | ❌ 否                          | ✅ 默认并发执行                  |
| 返回值类型      | 块内代码的返回值               | `Deferred`（需`await`）         |
| 常见应用场景    | 切换 IO/主线程，或 CPU 操作后更新 UI | 并行网络任务、合并异步操作结果      |

---

### 问题 3：协程和线程的区别？

- **协程是轻量级线程：**
    - 相比线程，协程的内存开销更小，创建协程可以上百万。
    - 线程是操作系统调度，而协程由协程调度器调度。
- **协程可以挂起恢复：**
    - 协程挂起不阻塞线程，线程资源可以运行其他任务。

---

### 问题 4：`Dispatchers.IO` 和普通子线程有啥区别？

| 特点       | 普通线程池                     | `Dispatchers.IO`                 |
|-----------|------------------------------|---------------------------------|
| 线程池大小  | 静态，线程数通常固定为 CPU 核数    | 动态扩展，上限 `64 x CPU`        |
| 场景适应性   | 适合有限任务并发                | 高并发、高吞吐率的 IO 密集型任务    |
| 系统调度    | 未优化 IO 任务开销              | IO 优化：线程池避免长时间阻塞       |

---

## 总结

Kotlin 协程提供高效率、结构化的异步能力，是 Android 开发中的重要技能。通过合理选择协程构建器（`launch`、`async`、`withContext`），结合调度器（`Dispatchers.Main`、`Dispatchers.IO`、`Dispatchers.Default`）应对多线程场景，可以显著提高代码的可读性和运行效率。